#version 430 core
layout (local_size_x = 16, local_size_y = 16) in;

layout (rgba32f, binding = 0) uniform image2D imgOutput;

uniform vec3 camPos;
uniform vec3 camTarget;
uniform vec3 camUp;

struct Ray {
    vec3 origin;
    vec3 dir;
};

bool intersectSphere(vec3 ro, vec3 rd, vec3 center, float radius, out float t) {
    vec3 oc = ro - center;
    float b = dot(oc, rd);
    float c = dot(oc, oc) - radius * radius;
    float h = b*b - c;
    if (h < 0.0) return false;
    h = sqrt(h);
    t = -b - h;
    if (t < 0.0) t = -b + h;
    return t >= 0.0;
}

vec3 getRayDir(vec2 uv, float aspect) {
    vec3 forward = normalize(camTarget - camPos);
    vec3 right = normalize(cross(forward, camUp));
    vec3 up = cross(right, forward);

    float fov = 1.0;
    return normalize(forward + uv.x * aspect * fov * right + uv.y * fov * up);
}

void main()
{
    ivec2 texCoord = ivec2(gl_GlobalInvocationID.xy);
    ivec2 texSize = imageSize(imgOutput);
    
    if(texCoord.x >= texSize.x || texCoord.y >= texSize.y)
        return;

    vec2 uv = (vec2(texCoord) / vec2(texSize)) * 2.0 - 1.0;
    float aspect = float(texSize.x) / float(texSize.y);

    vec3 rayDir = getRayDir(uv, aspect);

    vec3 sphereCenter = vec3(0.0, 0.0, 0.0);
    float sphereRadius = 0.5;
    vec3 sphereCenter2 = vec3(0.0, -1.0, 0.0);
    float sphereRadius2 = 0.5;

    vec3 color = vec3(0.0);

    float t1 = -1.0, t2 = -1.0;
    bool hit1 = intersectSphere(camPos, rayDir, sphereCenter, sphereRadius, t1);
    bool hit2 = intersectSphere(camPos, rayDir, sphereCenter2, sphereRadius2, t2);

    if (hit1 && (!hit2 || t1 < t2)) {
        color = vec3(1.0, 0.0, 0.0);
    } else if (hit2) {
        color = vec3(0.0, 0.0, 1.0);
    }

    imageStore(imgOutput, texCoord, vec4(color, 1.0));
}
