#version 430 core
// each workgroup have 16*16 threads
layout (local_size_x = 16, local_size_y = 16) in;

// getting the image from slot 0
layout (rgba32f, binding = 0) uniform image2D imgOutput;

uniform vec3 camPos;
uniform vec3 camTarget;
uniform vec3 camUp;
uniform int frameCount;
uniform vec2 resolution;
uniform int numSpheres;

struct Ray {
    vec3 origin;
    vec3 dir;
};

struct Sphere {
    vec3 center;
    float radius;
    vec3 color;
    int materialType;
};

layout(std430, binding = 1) buffer Spheres {
    float spheresData[];
};

#define MAX_BOUNCES 10

// i have no idea how it works randomness with these functions works
uint pcg_hash(uint seed) {
    uint state = seed * 747796405u + 2891336453u;
    uint word = ((state >> ((state >> 28u) + 4u)) ^ state) * 277803737u;
    return (word >> 22u) ^ word;
}

float rand_pcg(inout uint seed) {
    seed = pcg_hash(seed);
    return float(seed) / 4294967295.0;
}

uint generate_seed(ivec2 pixel, int frame) {
    uint seed = uint(pixel.x * 1973 + pixel.y * 9277 + frame * 26699);
    return pcg_hash(seed);
}

vec3 randomUnitSphere(vec3 normal, inout uint seed) {
    float u1 = rand_pcg(seed);
    float u2 = rand_pcg(seed);
    float r = sqrt(u1);
    float theta = 2.0 * 3.14159265 * u2;

    vec3 tangent = normalize(cross(normal, abs(normal.x) < 0.5 ? vec3(1,0,0) : vec3(0,1,0)));
    vec3 bitangent = cross(normal, tangent);

    vec3 sampleDir = r * cos(theta) * tangent + r * sin(theta) * bitangent + sqrt(1.0 - u1) * normal;
    return normalize(sampleDir);
}

vec3 randomHemisphere(vec3 normal, inout uint seed) {
    float u1 = rand_pcg(seed);
    float u2 = rand_pcg(seed);
    
    float r = sqrt(u1);
    float theta = 2.0 * 3.14159265 * u2;
    
    vec3 tangent = normalize(cross(normal, abs(normal.x) < 0.5 ? vec3(1,0,0) : vec3(0,1,0)));
    vec3 bitangent = cross(normal, tangent);

    vec3 sampleDir = r * cos(theta) * tangent + r * sin(theta) * bitangent + sqrt(1.0 - u1) * normal;
    return normalize(sampleDir);
}

bool intersectSphere(Ray ray, Sphere sphere, out float t, out vec3 normal) {
    vec3 oc = ray.origin - sphere.center;
    float b = dot(oc, ray.dir);
    float c = dot(oc, oc) - sphere.radius * sphere.radius;
    float h = b*b - c;
    if (h < 0.0) return false;
    h = sqrt(h);
    t = -b - h;
    if (t < 0.0) t = -b + h;
    if (t < 0.0) return false;

    vec3 hitPoint = ray.origin + ray.dir * t;
    normal = normalize(hitPoint - sphere.center);
    return true;
}

vec3 trace(Ray ray, inout uint seed) {
    vec3 throughput = vec3(1.0);
    vec3 accumColor = vec3(0.0);

    for(int bounce = 0; bounce < MAX_BOUNCES; ++bounce) {
        float closestT = 1e20;
        vec3 normal;
        Sphere hitSphere;
        bool hitSomething = false;

        for(int i = 0; i < numSpheres; ++i) {
            int base = i * 8;
            vec3 center = vec3(spheresData[base], spheresData[base+1], spheresData[base+2]);
            float radius = spheresData[base+3];
            vec3 color = vec3(spheresData[base+4], spheresData[base+5], spheresData[base+6]);
            int materialType = int(spheresData[base+7]);
            Sphere sphere = Sphere(center, radius, color, materialType);
            float t;
            vec3 n;
            if (intersectSphere(ray, sphere, t, n) && t < closestT) {
                closestT = t;
                normal = n;
                hitSphere = sphere;
                hitSomething = true;
            }
        }

        if(!hitSomething) {
            vec3 unitDir = normalize(ray.dir);
            float t = 0.5 * (unitDir.y + 1.0);
            // black sky
            vec3 sky = vec3(0);
            accumColor += throughput * sky;
            break;
        }

        float bias = 1e-3 * length(ray.origin - (ray.origin + ray.dir * closestT));
        vec3 hitPoint = ray.origin + ray.dir * closestT + normal * bias;

        // different functions soon for different materials
        if (hitSphere.materialType == 1) {
            accumColor += throughput * hitSphere.color;
            break;
        } else {
            vec3 newDir = randomHemisphere(normal, seed);
            ray = Ray(hitPoint, newDir);
            throughput *= hitSphere.color;
        }
    }

    return accumColor;
}

vec3 getRayDir(vec2 uv) {
    vec3 forward = normalize(camTarget - camPos);
    vec3 right = normalize(cross(forward, camUp));
    vec3 up = cross(right, forward);
    float fov = 1.0;
    float aspect = resolution.x / resolution.y;
    return normalize(forward + uv.x * aspect * fov * right + uv.y * fov * up);
}

void main() {
    ivec2 texCoord = ivec2(gl_GlobalInvocationID.xy);
    if(texCoord.x >= int(resolution.x) || texCoord.y >= int(resolution.y)) return;

    // Generate unique seed for this pixel and frame
    uint base_seed = generate_seed(texCoord, frameCount);
    
    // Use separate seeds for different random operations to avoid relation
    uint trace_seed = pcg_hash(base_seed + 2);

    const int numSamples = 1;
    vec3 col = vec3(0.0);
    // might remove later
    for(int i = 0; i < numSamples; i++){
        uint sample_seed = pcg_hash(trace_seed + i);
        float randX = rand_pcg(sample_seed);
        float randY = rand_pcg(sample_seed);
        vec2 uv = (vec2(texCoord) + vec2(randX, randY)) / resolution * 2.0 - 1.0;

        Ray camRay = Ray(camPos, getRayDir(uv));

        col += trace(camRay, sample_seed);
    }
    col /= float(numSamples);

    vec4 prev = imageLoad(imgOutput, texCoord);
    vec3 finalColor = (prev.rgb * float(frameCount) + col) / float(frameCount + 1);

    imageStore(imgOutput, texCoord, vec4(finalColor, 1.0));
}
