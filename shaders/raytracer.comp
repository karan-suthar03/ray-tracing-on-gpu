#version 430 core
// each workgroup have 16*16 threads
layout (local_size_x = 16, local_size_y = 16) in;

// getting the image from slot 0
layout (rgba32f, binding = 0) uniform image2D imgOutput;

uniform vec3 camPos;
uniform vec3 camTarget;
uniform vec3 camUp;
uniform int frameCount;
uniform vec2 resolution;
uniform int numSpheres;
uniform int numTriangles;

struct Ray {
    vec3 origin;
    vec3 dir;
};

struct Sphere {
    vec3 center;
    float radius;
    vec3 color;
    int materialType;
};

struct Triangle {
    vec3 v0, v1, v2;
    vec3 normal;
    vec3 color;
    int materialType;
};

layout(std430, binding = 1) buffer Spheres {
    float spheresData[];
};

layout(std430, binding = 2) buffer Triangles {
    float trianglesData[];
};

#define MAX_BOUNCES 10

// i have no idea how it works randomness with these functions works
uint pcg_hash(uint seed) {
    uint state = seed * 747796405u + 2891336453u;
    uint word = ((state >> ((state >> 28u) + 4u)) ^ state) * 277803737u;
    return (word >> 22u) ^ word;
}

float rand_pcg(inout uint seed) {
    seed = pcg_hash(seed);
    return float(seed) / 4294967295.0;
}

uint generate_seed(ivec2 pixel, int frame) {
    uint seed = uint(pixel.x * 1973 + pixel.y * 9277 + frame * 26699);
    return pcg_hash(seed);
}

vec3 randomUnitSphere(vec3 normal, inout uint seed) {
    float u1 = rand_pcg(seed);
    float u2 = rand_pcg(seed);
    float r = sqrt(u1);
    float theta = 2.0 * 3.14159265 * u2;

    vec3 tangent = normalize(cross(normal, abs(normal.x) < 0.5 ? vec3(1,0,0) : vec3(0,1,0)));
    vec3 bitangent = cross(normal, tangent);

    vec3 sampleDir = r * cos(theta) * tangent + r * sin(theta) * bitangent + sqrt(1.0 - u1) * normal;
    return normalize(sampleDir);
}

vec3 randomHemisphere(vec3 normal, inout uint seed) {
    float u1 = rand_pcg(seed);
    float u2 = rand_pcg(seed);
    
    float r = sqrt(u1);
    float theta = 2.0 * 3.14159265 * u2;
    
    vec3 tangent = normalize(cross(normal, abs(normal.x) < 0.5 ? vec3(1,0,0) : vec3(0,1,0)));
    vec3 bitangent = cross(normal, tangent);

    vec3 sampleDir = r * cos(theta) * tangent + r * sin(theta) * bitangent + sqrt(1.0 - u1) * normal;
    return normalize(sampleDir);
}

bool intersectSphere(Ray ray, Sphere sphere, float t_min, float t_max, out float t, out vec3 normal) {
    vec3 oc = ray.origin - sphere.center;
    float b = dot(oc, ray.dir);
    float c = dot(oc, oc) - sphere.radius * sphere.radius;
    float h = b*b - c;
    if (h < 0.0) return false;
    h = sqrt(h);
    t = -b - h;
    if (t < t_min || t > t_max) {
        t = -b + h;
        if (t < t_min || t > t_max) return false;
    }

    vec3 hitPoint = ray.origin + ray.dir * t;
    normal = normalize(hitPoint - sphere.center);
    return true;
}

// the exact same ray triangle intersection just like we did in the CPU based ray tracer
bool intersectTriangle(Ray ray, Triangle triangle, float t_min, float t_max, out float t, out vec3 normal) {
    const float epsilon = 1e-7;

    vec3 edge1 = triangle.v1 - triangle.v0;
    vec3 edge2 = triangle.v2 - triangle.v0;

    vec3 pvec = cross(ray.dir, edge2);
    float det = dot(edge1, pvec);

    if (det > -epsilon && det < epsilon)
        return false;

    float inv_det = 1.0 / det;
    vec3 tvec = ray.origin - triangle.v0;
    float u = inv_det * dot(tvec, pvec);

    if (u < 0.0 || u > 1.0)
        return false;

    vec3 qvec = cross(tvec, edge1);
    float v = inv_det * dot(ray.dir, qvec);

    if (v < 0.0 || u + v > 1.0)
        return false;

    t = inv_det * dot(edge2, qvec);

    if (t < t_min || t > t_max)
        return false;

    normal = triangle.normal;
    return true;
}

vec3 trace(Ray ray, inout uint seed) {
    vec3 throughput = vec3(1.0);
    vec3 accumColor = vec3(0.0);

    for(int bounce = 0; bounce < MAX_BOUNCES; ++bounce) {
        float closestT = 1e20;
        vec3 normal;
        Sphere hitSphere;
        Triangle hitTriangle;
        bool hitSomething = false;
        bool hitSphereObj = false;

        for(int i = 0; i < numSpheres; ++i) {
            int base = i * 8;
            vec3 center = vec3(spheresData[base], spheresData[base+1], spheresData[base+2]);
            float radius = spheresData[base+3];
            vec3 color = vec3(spheresData[base+4], spheresData[base+5], spheresData[base+6]);
            int materialType = int(spheresData[base+7]);
            Sphere sphere = Sphere(center, radius, color, materialType);
            float t;
            vec3 n;
            if (intersectSphere(ray, sphere, 0.0, closestT, t, n) && t < closestT) {
                closestT = t;
                normal = n;
                hitSphere = sphere;
                hitSomething = true;
                hitSphereObj = true;
            }
        }

        // Check triangles
        for(int i = 0; i < numTriangles; ++i) {
            int base = i * 16; // 9 vertices + 3 normal + 3 color + 1 material = 16 floats per triangle
            vec3 v0 = vec3(trianglesData[base], trianglesData[base+1], trianglesData[base+2]);
            vec3 v1 = vec3(trianglesData[base+3], trianglesData[base+4], trianglesData[base+5]);
            vec3 v2 = vec3(trianglesData[base+6], trianglesData[base+7], trianglesData[base+8]);
            vec3 triNormal = vec3(trianglesData[base+9], trianglesData[base+10], trianglesData[base+11]);
            vec3 color = vec3(trianglesData[base+12], trianglesData[base+13], trianglesData[base+14]);
            int materialType = int(trianglesData[base+15]);
            Triangle triangle = Triangle(v0, v1, v2, triNormal, color, materialType);
            float t;
            vec3 n;
            if (intersectTriangle(ray, triangle, 0.0, closestT, t, n) && t < closestT) {
                closestT = t;
                normal = n;
                hitTriangle = triangle;
                hitSomething = true;
                hitSphereObj = false;
            }
        }

        if(!hitSomething) {
            vec3 unitDir = normalize(ray.dir);
            float t = 0.5 * (unitDir.y + 1.0);
            // black sky
            vec3 sky = vec3(0);
            accumColor += throughput * sky;
            break;
        }

        float bias = 1e-3 * length(ray.origin - (ray.origin + ray.dir * closestT));
        vec3 hitPoint = ray.origin + ray.dir * closestT + normal * bias;

        // different functions soon for different materials
        int materialType;
        vec3 objectColor;
        if (hitSphereObj) {
            materialType = hitSphere.materialType;
            objectColor = hitSphere.color;
        } else {
            materialType = hitTriangle.materialType;
            objectColor = hitTriangle.color;
        }

        if (materialType == 1) {
            accumColor += throughput * objectColor;
            break;
        } else {
            vec3 newDir = randomHemisphere(normal, seed);
            ray = Ray(hitPoint, newDir);
            throughput *= objectColor;
        }
    }

    return accumColor;
}

vec3 getRayDir(vec2 uv) {
    vec3 forward = normalize(camTarget - camPos);
    vec3 right = normalize(cross(forward, camUp));
    vec3 up = cross(right, forward);
    float fov = 1.0;
    float aspect = resolution.x / resolution.y;
    return normalize(forward + uv.x * aspect * fov * right + uv.y * fov * up);
}

void main() {
    ivec2 texCoord = ivec2(gl_GlobalInvocationID.xy);
    if(texCoord.x >= int(resolution.x) || texCoord.y >= int(resolution.y)) return;

    // Generate unique seed for this pixel and frame
    uint base_seed = generate_seed(texCoord, frameCount);
    
    // Use separate seeds for different random operations to avoid relation
    uint trace_seed = pcg_hash(base_seed + 2);

    const int numSamples = 1;
    vec3 col = vec3(0.0);
    // might remove later
    for(int i = 0; i < numSamples; i++){
        uint sample_seed = pcg_hash(trace_seed + i);
        float randX = rand_pcg(sample_seed);
        float randY = rand_pcg(sample_seed);
        vec2 uv = (vec2(texCoord) + vec2(randX, randY)) / resolution * 2.0 - 1.0;

        Ray camRay = Ray(camPos, getRayDir(uv));

        col += trace(camRay, sample_seed);
    }
    col /= float(numSamples);

    vec4 prev = imageLoad(imgOutput, texCoord);
    vec3 finalColor = (prev.rgb * float(frameCount) + col) / float(frameCount + 1);

    imageStore(imgOutput, texCoord, vec4(finalColor, 1.0));
}
